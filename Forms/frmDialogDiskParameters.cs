
//This code has been automatically generated by DudeLabs LLC RCConverter
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

using System.IO;
using System.Xml;

using System.Runtime.Serialization.Formatters.Binary;

namespace FloppyMaintenance
{
	/// <summary>
	/// Summary description for frmDialogDiskParameters.
	/// </summary>
	public partial class frmDialogDiskParameters : System.Windows.Forms.Form
    {
        frmProgress alert = new frmProgress();

        string filename = null;
        int nProgressSectors;
        int nTotalSectors;
        bool createdDisk = false;

        public string Filename { get => filename; set => filename = value; }
        public bool CreatedDisk { get => createdDisk; set => createdDisk = value; }

        #region boot sector images
        byte[] caBootSector6800 = new byte[256]
        {
            0x8E, 0xA0, 0x7F, 0x20, 0x08, 0x01, 0x01, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x0B, 0xB7, 
            0x80, 0x18, 0x8D, 0x40, 0x8D, 0x58, 0x8D, 0x5E, 
            0x8D, 0x3C, 0x81, 0x02, 0x27, 0x13, 0x81, 0x16, 
            0x26, 0xF6, 0x8D, 0x32, 0xB7, 0xA1, 0x07, 0x8D, 
            0x2D, 0xB7, 0xA1, 0x08, 0xFE, 0xA1, 0x07, 0x6E, 
            0x00, 0x8D, 0x23, 0x36, 0x8D, 0x20, 0x33, 0xB7, 
            0xA1, 0x0A, 0xF7, 0xA1, 0x09, 0x8D, 0x17, 0x16, 
            0x27, 0xD6, 0x37, 0x8D, 0x11, 0x33, 0xFE, 0xA1, 
            0x09, 0xA7, 0x00, 0x08, 0xFF, 0xA1, 0x09, 0x5A, 
            0x26, 0xF0, 0x20, 0xC4, 0x20, 0x79, 0xFE, 0xA1, 
            0x0B, 0x8C, 0xA2, 0xD4, 0x27, 0x05, 0xA6, 0x00, 
            0x08, 0x20, 0x46, 0xCE, 0xA1, 0xD4, 0xA6, 0x00, 
            0xE6, 0x01, 0x8D, 0x10, 0x20, 0xE8, 0xF6, 0x80, 
            0x18, 0xC5, 0x01, 0x26, 0xF9, 0x39, 0xB6, 0xA1, 
            0x05, 0xF6, 0xA1, 0x06, 0x8D, 0x2F, 0x86, 0x8C, 
            0xB7, 0x80, 0x18, 0x8D, 0x4A, 0x5F, 0xCE, 0xA1, 
            0xD4, 0xB6, 0x80, 0x18, 0x85, 0x02, 0x26, 0x07, 
            0x85, 0x01, 0x26, 0xF5, 0x7E, 0xA1, 0x00, 0xB6, 
            0x80, 0x1B, 0xA7, 0x00, 0x08, 0x5A, 0x26, 0xE9, 
            0x8D, 0xCC, 0xC5, 0x1C, 0x26, 0xEE, 0xCE, 0xA1, 
            0xD8, 0xFF, 0xA1, 0x0B, 0x39, 0xB1, 0x80, 0x19, 
            0x27, 0x10, 0xB7, 0x80, 0x1B, 0x8D, 0x18, 0x86, 
            0x18, 0xB7, 0x80, 0x18, 0x8D, 0x11, 0x37, 0x8D, 
            0xAD, 0x33, 0xF7, 0x80, 0x1A, 0x4F, 0xC1, 0x0A, 
            0x23, 0x02, 0x86, 0x80, 0xB7, 0x80, 0x14, 0x8D, 
            0x00, 0x8D, 0x00, 0x39, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        byte [] caBootSector6809 = new byte[256]
        {
            0x16, 0x00, 0x7F, 0x12, 0x20, 0x01, 0x01, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xC0, 0x05,
            0x8D, 0x2D, 0x86, 0x8C, 0xB7, 0xE0, 0x18, 0x8D,
            0x47, 0x5F, 0x8E, 0xC0, 0xD0, 0xB6, 0xE0, 0x18,
            0x85, 0x02, 0x26, 0x06, 0x85, 0x01, 0x26, 0xF5,
            0x20, 0xD6, 0xB6, 0xE0, 0x1B, 0xA7, 0x80, 0x5A,
            0x26, 0xEB, 0x8D, 0x31, 0xC5, 0x1C, 0x26, 0xC8,
            0x8E, 0xC0, 0xD4, 0xBF, 0xC0, 0x0B, 0x39, 0xF7,
            0xE0, 0x1A, 0xC1, 0x0B, 0xC6, 0x00, 0x25, 0x02,
            0xC6, 0x80, 0xF7, 0xE0, 0x14, 0xB1, 0xE0, 0x19,
            0x27, 0x0E, 0xB7, 0xE0, 0x1B, 0x8D, 0x09, 0x86,
            0x1B, 0xB7, 0xE0, 0x18, 0x8D, 0x02, 0x8D, 0x05,
            0x8D, 0x00, 0x8D, 0x00, 0x39, 0xF6, 0xE0, 0x18,
            0xC5, 0x01, 0x26, 0xF9, 0x39, 0xBE, 0xC0, 0x0B,
            0x8C, 0xC1, 0xD0, 0x27, 0x04, 0xA6, 0x80, 0x20,
            0xC2, 0x8E, 0xC0, 0xD0, 0xEC, 0x84, 0x8D, 0x90,
            0x20, 0xEB, 0x86, 0x0B, 0xB7, 0xE0, 0x18, 0x8D,
            0xD7, 0x8D, 0xDA, 0x17, 0xFF, 0x7F, 0x8D, 0xDD,
            0x81, 0x02, 0x27, 0x12, 0x81, 0x16, 0x26, 0xF6,
            0x8D, 0xD3, 0xB7, 0xC0, 0x07, 0x8D, 0xCE, 0xB7,
            0xC0, 0x08, 0x6E, 0x9F, 0xC0, 0x07, 0x8D, 0xC5,
            0x34, 0x02, 0x8D, 0xC1, 0x35, 0x04, 0xB7, 0xC0,
            0x0A, 0xF7, 0xC0, 0x09, 0x8D, 0xB7, 0x1F, 0x89,
            0x4D, 0x27, 0xD3, 0x34, 0x04, 0x8D, 0xAE, 0x35,
            0x04, 0xBE, 0xC0, 0x09, 0xA7, 0x80, 0xBF, 0xC0,
            0x09, 0x5A, 0x26, 0xEF, 0x20, 0xC0, 0x00, 0xFF,
            0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
            0x00, 0xFF, 0x00, 0xFF, 0x7E, 0xC7, 0x23, 0x7E,
            0xC7, 0x03, 0x7E, 0xC7, 0x47, 0x7E, 0xC7, 0x85,
            0x7E, 0xC7, 0x95, 0x7E, 0xC7, 0x1F, 0x0C, 0x00,
            0x00, 0x00, 0x00, 0xC8, 0x10, 0xC8, 0x10, 0x00,
            0x00, 0x00, 0x00, 0x6E, 0x9F, 0xD3, 0xE7, 0xBE
        };

        byte [] BootSector6809DMAF2 = new byte[512]
        {
            0x86, 0xF0, 0x20, 0x09, 0x00, 0x01, 0x02, 0x10, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x1F, 0x8B, 0x32,
            0x8D, 0x03, 0x2D, 0x0D, 0x10, 0x0D, 0x10, 0x2A, 0x03, 0x63, 0x8C, 0xEF, 0x6D, 0x8C, 0xE5, 0x26,
            0x05, 0x86, 0x1B, 0xA7, 0x8C, 0xE1, 0x86, 0x02, 0x97, 0x22, 0x17, 0x00, 0x95, 0x30, 0x8D, 0x00,
            0xCF, 0x8D, 0x22, 0x10, 0x27, 0x00, 0xDD, 0x30, 0x8C, 0x08, 0xAD, 0x9F, 0xF8, 0x0C, 0x6E, 0x9F,
            0xFF, 0xFE, 0x2D, 0x20, 0x43, 0x61, 0x6E, 0x27, 0x74, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x49,
            0x50, 0x4C, 0x0D, 0x0A, 0x04, 0xAD, 0x9F, 0xF8, 0x12, 0x6D, 0x8C, 0xAF, 0x2B, 0x04, 0x97, 0x25,
            0x20, 0x04, 0x8A, 0x10, 0x97, 0x40, 0x1F, 0x10, 0xA8, 0x8C, 0xA0, 0xE8, 0x8C, 0x9D, 0xDD, 0x00,
            0xCC, 0x01, 0x00, 0xA8, 0x8C, 0x95, 0xE8, 0x8C, 0x92, 0xDD, 0x02, 0xD7, 0x10, 0x97, 0x14, 0x86,
            0x8C, 0xAA, 0x8C, 0x88, 0x97, 0x20, 0x8E, 0xF0, 0x00, 0x96, 0x10, 0xA8, 0x8D, 0xFF, 0x7C, 0x2B,
            0x04, 0x30, 0x1F, 0x26, 0xF4, 0xA6, 0x8D, 0xFF, 0x72, 0x97, 0x14, 0x8D, 0x03, 0xC5, 0x9C, 0x39,
            0x8D, 0x19, 0xC5, 0x10, 0x27, 0x14, 0x6D, 0x8D, 0xFF, 0x5A, 0x26, 0x0E, 0x86, 0x1E, 0xA1, 0x8D,
            0xFF, 0x55, 0x26, 0x02, 0x86, 0x1B, 0xA7, 0x8D, 0xFF, 0x4D, 0x39, 0xD6, 0x20, 0xC5, 0x01, 0x26,
            0xFA, 0x39, 0x8D, 0x00, 0x8D, 0x00, 0x8D, 0x00, 0x39, 0xD7, 0x22, 0x6F, 0x8D, 0xFF, 0x3D, 0xE1,
            0x8D, 0xFF, 0x34, 0xC6, 0x81, 0x25, 0x14, 0x6D, 0x8D, 0xFF, 0x30, 0x2B, 0x0C, 0x6D, 0x8D, 0xFF,
            0x23, 0x26, 0x06, 0xC6, 0x02, 0xE7, 0x8D, 0xFF, 0x23, 0xC6, 0x91, 0xEA, 0x8D, 0xFF, 0x15, 0x6D,
            0x8D, 0xFF, 0x18, 0x2B, 0x08, 0xC4, 0x7F, 0xC5, 0x20, 0x27, 0x02, 0xCA, 0x40, 0xE8, 0x8D, 0xFF,
            0x0A, 0xD7, 0x24, 0x91, 0x21, 0x27, 0x0C, 0x97, 0x23, 0x8D, 0xB7, 0x86, 0x19, 0x97, 0x20, 0x8D,
            0xB1, 0x8D, 0xA8, 0x39, 0xEC, 0x8D, 0xFE, 0xED, 0x10, 0x27, 0x00, 0x7F, 0x33, 0x8D, 0x01, 0xE0,
            0xEF, 0x8D, 0xFE, 0xE4, 0x8D, 0x3D, 0x81, 0x02, 0x27, 0x10, 0x81, 0x16, 0x26, 0xF6, 0x8D, 0x33,
            0xA7, 0xE3, 0x8D, 0x2F, 0xA7, 0x61, 0x4F, 0x1F, 0x8B, 0x39, 0x8D, 0x27, 0xA7, 0xE3, 0x8D, 0x23,
            0xA7, 0x61, 0x35, 0x20, 0x8D, 0x1D, 0x27, 0xDC, 0x1F, 0x89, 0x34, 0x04, 0x8D, 0x15, 0xA7, 0xA0,
            0x35, 0x04, 0x5A, 0x26, 0xF5, 0x20, 0xCD, 0x33, 0x8D, 0x00, 0xA5, 0xEC, 0xC4, 0xED, 0x8D, 0xFE,
            0xA4, 0x33, 0x44, 0x11, 0xA3, 0x8D, 0xFE, 0xA0, 0x27, 0x03, 0xA6, 0xC0, 0x39, 0xEC, 0x8D, 0xFE,
            0x94, 0x27, 0x22, 0x30, 0x8D, 0x00, 0x89, 0x17, 0xFF, 0x4F, 0x17, 0xFE, 0xD8, 0x27, 0xD8, 0x86,
            0x09, 0x97, 0x20, 0x17, 0xFF, 0x3C, 0x17, 0xFF, 0x32, 0x6A, 0x8D, 0xFE, 0x7D, 0x26, 0xDE, 0x30,
            0x8C, 0x1E, 0x16, 0xFE, 0xA5, 0x30, 0x8C, 0x2E, 0x16, 0xFE, 0x9F, 0x30, 0x8C, 0x03, 0x16, 0xFE,
            0x99, 0x2D, 0x20, 0x4E, 0x6F, 0x74, 0x20, 0x4C, 0x69, 0x6E, 0x6B, 0x65, 0x64, 0x0D, 0x0A, 0x04,
            0x2D, 0x20, 0x4E, 0x75, 0x63, 0x6C, 0x65, 0x75, 0x73, 0x20, 0x49, 0x2F, 0x4F, 0x20, 0x45, 0x72,
            0x72, 0x6F, 0x72, 0x0D, 0x0A, 0x04, 0x2D, 0x20, 0x42, 0x61, 0x64, 0x20, 0x4E, 0x75, 0x63, 0x6C,
            0x65, 0x75, 0x73, 0x0D, 0x0A, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        };
        #endregion

        #region variables
        int  m_nSectorsPerCylinder;
        int  m_nCylindersPerDisk;

        string m_volumeName = null;

        byte[] m_caSector = new byte[256];
        byte m_cSectorsPerCylinder;
        byte m_cCylindersPerDisk;

        int m_nProcessor;

        bool m_nIncludeBootSector;

        bool m_35Track;
	    bool m_40Track;
	    bool m_80Track;
	    bool m_UserDefined;

	    bool m_DoubleDensity;
	    bool m_SingleDensity;
        bool m_QuadDensity;
        bool m_DoubleSided;

	    int m_CylindersPerDisk;
	    int m_SectorsPerTrack;
        int m_SectorsPerTrack0;

        int m_UserDefinedCylindersPerDisk;
	    int m_UserDefinedSectorsPerTrack;
        int m_nControllerType;

        string m_fileFormat;

        #endregion

        enum ControllerTypes
        {
            CONTROLLER_TYPE_FD2 = 0,
            CONTROLLER_TYPE_DMAF2
        }

        public frmDialogDiskParameters()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //

            m_fileFormat                    = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "Format"                , "FLEX");

            m_nProcessor                    = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "Processor"             , 6809);
            m_nIncludeBootSector            = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "IncludeBootSector"     , "1") == "1" ? true : false;

            m_35Track                       = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "Tracks35"              , "0") == "1" ? true : false;
            m_40Track                       = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "Tracks40"              , "0") == "1" ? true : false;
            m_80Track                       = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "Tracks80"              , "1") == "1" ? true : false;
            m_UserDefined                   = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "UserDefined"           , "0") == "1" ? true : false;

            m_DoubleDensity                 = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "DoubleDensity"         , "1") == "1" ? true : false;
            m_SingleDensity                 = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "SingleDensity"         , "0") == "1" ? true : false;
            m_QuadDensity                   = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "QuadDensity"           , "0") == "1" ? true : false;
            m_DoubleSided                   = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "DoubleSided"           , "1") == "1" ? true : false;

            m_UserDefinedCylindersPerDisk   = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "UserDefinedCylinders"  , 80);
            m_UserDefinedSectorsPerTrack    = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "UserDefinedSectors"    , 18);

            m_CylindersPerDisk = m_UserDefinedCylindersPerDisk;
            m_SectorsPerTrack  = m_UserDefinedSectorsPerTrack;

            m_SectorsPerTrack0 = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "SectorsPerTrack0", 10);
            m_nControllerType  = Program.GetConfigurationAttribute("Global/FileMaintenance/FloppyCreate", "ControllerType"  , 0);

            ToolTip toolTipCheckMakeGoTekCompatible = new ToolTip();

            // Set up the delays for the ToolTip.
            toolTipCheckMakeGoTekCompatible.InitialDelay = 1000;
            toolTipCheckMakeGoTekCompatible.ReshowDelay = 500;
            toolTipCheckMakeGoTekCompatible.AutoPopDelay = 5000;

            // Force the ToolTip text to be displayed whether or not the form is active.

            toolTipCheckMakeGoTekCompatible.ShowAlways = true;

            // Set up the ToolTip text for Checkbox.

            toolTipCheckMakeGoTekCompatible.SetToolTip(this.checkBoxGoTekCompatible, "This format is not compatible with the emulator. Use with caution.");
        }

        // Convert an object to a byte array
        private byte[] ObjectToByteArray(Object obj)
        {
            if (obj == null)
                return null;

            BinaryFormatter bf = new BinaryFormatter();
            MemoryStream ms = new MemoryStream();
            bf.Serialize(ms, obj);

            return ms.ToArray();
        }

        // Convert a byte array to an Object
        private Object ByteArrayToObject(byte[] arrBytes)
        {
            MemoryStream memStream = new MemoryStream();
            BinaryFormatter binForm = new BinaryFormatter();
            memStream.Write(arrBytes, 0, arrBytes.Length);
            memStream.Seek(0, SeekOrigin.Begin);
            Object obj = (Object)binForm.Deserialize(memStream);

            return obj;
        }

        private void ClearSectorBuffer()
        {
            // memset(m_caSector, '\0', 256);           // clear the sector buffer

            for (int i = 0; i < 256; i++)
                m_caSector[i] = 0x00;
        }

        //StreamReader reader = new StreamReader(File.Open(pDlg.FileName, FileMode.Open, FileAccess.Read, FileShare.None));
        //string _textToDisplay = reader.ReadToEnd();
        //reader.Close();

        //virtualFloppyManipulationRoutines.Write(dialogConfigType, pDlg.SafeFileName, ASCIIEncoding.ASCII.GetBytes(_textToDisplay), m_fp);
        //RefreshList();

        private int PrepareOS9SIRForCreate(ref OS9_ID_SECTOR stIdentSector, DateTime ltime)
        {
            int nSectorsPerCluster = 1;

            try
            {

                //
                // set up stIdentSector
                //

                // Total Number of sector on media

                stIdentSector.cTOT[0] = (byte)(nTotalSectors / 65536);
                stIdentSector.cTOT[1] = (byte)((nTotalSectors % 65536) / 256);
                stIdentSector.cTOT[2] = (byte)(nTotalSectors % 256);

                // Number of sector per track

                m_nSectorsPerCylinder = m_SectorsPerTrack * (chkCheckDoubleSided.Checked ? 2 : 1);

                stIdentSector.cTKS[0] = (byte)(m_SectorsPerTrack0);

                // Number of bytes in allocation map
                //
                //  see if number of sectors will result in an allocation table that is larger than two
                //  sectors. Keep doing this while shifting  cBIT to the left.

                int sectorsThisFormat = 0;
                for (sectorsThisFormat = 1; sectorsThisFormat <= 16; sectorsThisFormat *= 2)
                {
                    if (((nTotalSectors + 8) / (8 * sectorsThisFormat)) <= 512)
                    {
                        nSectorsPerCluster = sectorsThisFormat;
                        break;
                    }
                }

                stIdentSector.cMAP[0] = (byte)(((nTotalSectors + 8) / (8 * sectorsThisFormat)) / 256);
                stIdentSector.cMAP[1] = (byte)(((nTotalSectors + 8) / (8 * sectorsThisFormat)) % 256);

                int bytesInAllocationBitMap = (nTotalSectors + 8) / (8 * sectorsThisFormat);
                //int bytesInAllocationBitMap = (stIdentSector.cMAP[0] * 256) + stIdentSector.cMAP[1];

                // Number of sectors per cluster

                stIdentSector.cBIT[0] = (byte)(nSectorsPerCluster / 256);
                stIdentSector.cBIT[1] = (byte)(nSectorsPerCluster % 256);

                // Starting sector of root directory

                if (bytesInAllocationBitMap > 256)
                {
                    // if the number of bytes required for the allocation bit map is > 256 we can not fit them all
                    // into 1 sector, so let's styart the root directory at LSN 3 instead of LSN 2. The number of
                    // sectors used by the allocation bit map cannot exceed 2 (512 bytes).

                    stIdentSector.cDIR[0] = 0x00;
                    stIdentSector.cDIR[1] = 0x00;
                    stIdentSector.cDIR[2] = 0x03;
                }
                else
                {
                    // if the number of bytes required for the allocation bit map is <= 256 we can fit them all
                    // into 1 sector, so let's styart the root directory at LSN 2 instead of LSN 3

                    stIdentSector.cDIR[0] = 0x00;
                    stIdentSector.cDIR[1] = 0x00;
                    stIdentSector.cDIR[2] = 0x02;
                }

                // Owners user number

                stIdentSector.cOWN[0] = 0x00;
                stIdentSector.cOWN[1] = 0x00;

                // Disk attributes

                stIdentSector.cATT[0] = 0xFF;

                // Disk Identification

                stIdentSector.cDSK[0] = 0x00;
                stIdentSector.cDSK[1] = 0x00;

                // Disk Format: density, number of sides

                stIdentSector.cFMT[0] = 0x00;
                if (!rdoRadioSingleDensity.Checked)
                    stIdentSector.cFMT[0] |= 0x01;

                if (chkCheckDoubleSided.Checked)
                    stIdentSector.cFMT[0] |= 0x02;

                // Number of sectors per track

                stIdentSector.cSPT[0] = 0x00;
                stIdentSector.cSPT[1] = (byte)(m_SectorsPerTrack);

                // Reserved for future use

                stIdentSector.cRES[0] = 0x00;
                stIdentSector.cRES[1] = 0x00;

                // Starting sector of bootstrap file

                stIdentSector.cBT[0] = 0x00;
                stIdentSector.cBT[1] = 0x00;
                stIdentSector.cBT[2] = 0x00;

                // Size of bootstrap file (in bytes)

                stIdentSector.cBSZ[0] = 0x00;
                stIdentSector.cBSZ[1] = 0x00;

                // Time of creation Y:M:D:H:M

                stIdentSector.cDAT[0] = (byte)(ltime.Year - 1900);
                stIdentSector.cDAT[1] = (byte)(ltime.Month);
                stIdentSector.cDAT[2] = (byte)(ltime.Day);      // today.tm_mday;
                stIdentSector.cDAT[3] = (byte)(ltime.Hour);     // today.tm_hour;
                stIdentSector.cDAT[4] = (byte)(ltime.Minute);   // today.tm_min;

                // Volume name (last char has sign bit set)

                for (int i = 0; i < 32; i++)
                {
                    if (i < m_volumeName.Length)
                    {
                        string b = m_volumeName.Substring(i, 1);
                        if (i == m_volumeName.Length - 1)
                            stIdentSector.cNAM[i] = (byte)(b.ToCharArray(0, 1)[0] | 0x80);
                        else
                            stIdentSector.cNAM[i] = (byte)b.ToCharArray(0, 1)[0];

                    }
                    else
                        stIdentSector.cNAM[i] = (byte)0x00;
                }

                // now do the old DD_OPTS (Path Options).

                stIdentSector.cOPTS.pd_dtp[0] = 1;      // this is what toolshed is hard coded to place here - so we will too
                stIdentSector.cOPTS.pd_drv[0] = 1;      // this is what toolshed is hard coded to place here - so we will too
                stIdentSector.cOPTS.pd_stp[0] = 0;      // this is what toolshed is hard coded to place here - so we will too
                stIdentSector.cOPTS.pd_typ[0] = 0x20;   // this is 0x20 for floppy and 0x80 for hdd
                stIdentSector.cOPTS.pd_dns[0] = 1;      // this is what toolshed is hard coded to place here - so we will too
                stIdentSector.cOPTS.pd_cyl[0] = (byte)(m_nCylindersPerDisk / 256);
                stIdentSector.cOPTS.pd_cyl[1] = (byte)(m_nCylindersPerDisk % 256);
                stIdentSector.cOPTS.pd_sid[0] = (byte)(m_DoubleSided == true ? 2 : 1);  // number of heads
                stIdentSector.cOPTS.pd_vfy[0] = 0;      // this is what toolshed is hard coded to place here - so we will too
                stIdentSector.cOPTS.pd_sct[0] = stIdentSector.cSPT[0];
                stIdentSector.cOPTS.pd_sct[1] = stIdentSector.cSPT[1];
                stIdentSector.cOPTS.pd_t0s[0] = (byte)(m_SectorsPerTrack0 / 256);
                stIdentSector.cOPTS.pd_t0s[0] = (byte)(m_SectorsPerTrack0 % 256);
                stIdentSector.cOPTS.pd_ilv[0] = 3;      // this is what toolshed is hard coded to place here - so we will too
                stIdentSector.cOPTS.pd_sas[0] = 8;      // this is what toolshed defaults to - so we will too

                // these are for OS-9/68K

                /* put sync bytes */

                stIdentSector.cDD_SYNC[0] = 0x43;
                stIdentSector.cDD_SYNC[1] = 0x72;
                stIdentSector.cDD_SYNC[2] = 0x75;
                stIdentSector.cDD_SYNC[3] = 0x7A;

                /* put bitmap starting sector number */

                stIdentSector.cDD_MapLSN[0] = 0x00;
                stIdentSector.cDD_MapLSN[1] = 0x00;
                stIdentSector.cDD_MapLSN[2] = 0x00;
                stIdentSector.cDD_MapLSN[3] = 0x01;

                /* put bytes per sector */

                stIdentSector.cDD_LSNSize[0] = 0;
                stIdentSector.cDD_LSNSize[1] = 0;

                /* put sector 0 version ID */

                stIdentSector.cDD_VersID[0] = 0;
                stIdentSector.cDD_VersID[1] = 1;
            }
            catch (Exception e0)
            {
                MessageBox.Show("E0: " + e0.Message);
            }

            return nSectorsPerCluster;
        }

        private void WriteOS9SIRToImage (FileStream fp, OS9_ID_SECTOR stIdentSector)
        {
            //
            // write OS9 system id sector as sector 0
            //

            fp.Seek(0, SeekOrigin.Begin);

            m_caSector[0] = stIdentSector.cTOT[0];      //  new byte[3];      // Total Number of sector on media
            m_caSector[1] = stIdentSector.cTOT[1];
            m_caSector[2] = stIdentSector.cTOT[2];

            m_caSector[3] = stIdentSector.cTKS[0];      //  = new byte[1];      // Number of sector per track

            m_caSector[4] = stIdentSector.cMAP[0];      //  = new byte[2];      // Number of bytes in allocation map
            m_caSector[5] = stIdentSector.cMAP[1];

            m_caSector[6] = stIdentSector.cBIT[0];      //  = new byte[2];      // Number of sectors per cluster
            m_caSector[7] = stIdentSector.cBIT[1];

            m_caSector[8] = stIdentSector.cDIR[0];      //  = new byte[3];      // Starting sector of root directory
            m_caSector[9] = stIdentSector.cDIR[1];
            m_caSector[10] = stIdentSector.cDIR[2];

            m_caSector[11] = stIdentSector.cOWN[0];      //  = new byte[2];      // Owners user number
            m_caSector[12] = stIdentSector.cOWN[1];

            m_caSector[13] = stIdentSector.cATT[0];      //  = new byte[1];      // Disk attributes

            m_caSector[14] = stIdentSector.cDSK[0];      //  = new byte[2];      // Disk Identification
            m_caSector[15] = stIdentSector.cDSK[1];

            m_caSector[16] = stIdentSector.cFMT[0];      //  = new byte[1];      // Disk Format: density, number of sides

            m_caSector[17] = stIdentSector.cSPT[0];      //  = new byte[2];      // Number of sectors per track
            m_caSector[18] = stIdentSector.cSPT[1];

            m_caSector[19] = stIdentSector.cRES[0];      //  = new byte[2];      // Reserved for future use
            m_caSector[20] = stIdentSector.cRES[1];

            m_caSector[21] = stIdentSector.cBT[0];       //  = new byte[3];       // Starting sector of bootstrap file
            m_caSector[22] = stIdentSector.cBT[1];
            m_caSector[23] = stIdentSector.cBT[2];

            m_caSector[24] = stIdentSector.cBSZ[0];      //  = new byte[2];      // Size of bootstrap file (in bytes)
            m_caSector[25] = stIdentSector.cBSZ[1];

            m_caSector[26] = stIdentSector.cDAT[0];      //  = new byte[5];      // Time of creation Y:M:D:H:M
            m_caSector[27] = stIdentSector.cDAT[1];
            m_caSector[28] = stIdentSector.cDAT[2];
            m_caSector[29] = stIdentSector.cDAT[3];
            m_caSector[30] = stIdentSector.cDAT[4];

            for (int i = 0; i < 32; i++)
            {
                m_caSector[31 + i] = stIdentSector.cNAM[i];      //  = new byte[32];     // Volume name (last char has sign bit set)
            }

            // let's do the old dd_opts to make our image compatible with toolshed.

            /* These used to be called dd_opt[32] */

            m_caSector[63] = stIdentSector.cOPTS.pd_dtp[0];
            m_caSector[64] = stIdentSector.cOPTS.pd_drv[0];
            m_caSector[65] = stIdentSector.cOPTS.pd_stp[0];
            m_caSector[66] = stIdentSector.cOPTS.pd_typ[0];
            m_caSector[67] = stIdentSector.cOPTS.pd_dns[0];
            m_caSector[68] = stIdentSector.cOPTS.pd_cyl[0];
            m_caSector[69] = stIdentSector.cOPTS.pd_cyl[1];
            m_caSector[70] = stIdentSector.cOPTS.pd_sid[0];
            m_caSector[71] = stIdentSector.cOPTS.pd_vfy[0];
            m_caSector[72] = stIdentSector.cOPTS.pd_sct[0];
            m_caSector[73] = stIdentSector.cOPTS.pd_sct[1];
            m_caSector[74] = stIdentSector.cOPTS.pd_t0s[0];
            m_caSector[75] = stIdentSector.cOPTS.pd_t0s[1];
            m_caSector[76] = stIdentSector.cOPTS.pd_ilv[0];
            m_caSector[77] = stIdentSector.cOPTS.pd_sas[0];
            m_caSector[78] = stIdentSector.cOPTS.pd_tfm[0];
            m_caSector[79] = stIdentSector.cOPTS.pd_exten[0];
            m_caSector[80] = stIdentSector.cOPTS.pd_exten[1];
            m_caSector[81] = stIdentSector.cOPTS.pd_stoff[0];
            m_caSector[82] = stIdentSector.cOPTS.pd_att[0];
            m_caSector[83] = stIdentSector.cOPTS.pd_fd[0];
            m_caSector[84] = stIdentSector.cOPTS.pd_fd[1];
            m_caSector[85] = stIdentSector.cOPTS.pd_fd[2];
            m_caSector[86] = stIdentSector.cOPTS.pd_dfd[0];
            m_caSector[87] = stIdentSector.cOPTS.pd_dfd[1];
            m_caSector[88] = stIdentSector.cOPTS.pd_dfd[2];
            m_caSector[89] = stIdentSector.cOPTS.pd_dcp[0];
            m_caSector[90] = stIdentSector.cOPTS.pd_dcp[1];
            m_caSector[91] = stIdentSector.cOPTS.pd_dcp[2];
            m_caSector[92] = stIdentSector.cOPTS.pd_dcp[3];
            m_caSector[93] = stIdentSector.cOPTS.pd_dvt[0];
            m_caSector[94] = stIdentSector.cOPTS.pd_dvt[1];

            //  These are used by OS-9/68K */

            m_caSector[94] = stIdentSector.cDD_RES      [0];  //   $5F 1 Reserved
            m_caSector[94] = stIdentSector.cDD_SYNC     [0];  //   $60 4 DD_SYNC Media integrity code
            m_caSector[94] = stIdentSector.cDD_SYNC     [1];  
            m_caSector[94] = stIdentSector.cDD_SYNC     [2];  
            m_caSector[94] = stIdentSector.cDD_SYNC     [3];  
            m_caSector[94] = stIdentSector.cDD_MapLSN   [0];  //   $64 4 DD_MapLSN Bitmap starting sector number(0=LSN 1)
            m_caSector[94] = stIdentSector.cDD_MapLSN   [1];  
            m_caSector[94] = stIdentSector.cDD_MapLSN   [2];  
            m_caSector[94] = stIdentSector.cDD_MapLSN   [3];  
            m_caSector[94] = stIdentSector.cDD_LSNSize  [0];  //   $68 2 DD_LSNSize Media logical sector size(0=256)
            m_caSector[94] = stIdentSector.cDD_LSNSize  [1];  
            m_caSector[94] = stIdentSector.cDD_VersID   [0];  //   $6A 2 DD_VersID Sector 0 Version ID
            m_caSector[94] = stIdentSector.cDD_VersID   [1];  

            //dd_res1[1],
            //dd_sync[4],		//  CRUZ
            //dd_maplsn[4],
            //dd_lsnsize[2],
            //dd_versid[2];

            fp.Write(m_caSector, 0, 256);                           // write identiy sector     (0)

        }

        private int WriteOS9AllocationBitMap (FileStream fp, OS9_ID_SECTOR stIdentSector, int nSectorsPerCluster)
        {
            // the Allocation bit map must fit within 2 sectors, so make sure we write out 512 bytes in this procedure.

            int nOS9DirSectors = 0;
            int bytesInAllocationBitMap = (stIdentSector.cMAP[0] * 256) + stIdentSector.cMAP[1];

            int bytesWritten = 0;

            try
            {
                //
                // write the allocation map. 
                //
                //      a blank disk uses 11 sectors so the initial mask for 
                //      a disk that has 1 sector per cluster is 0xFFE0. This 
                //      gives the root directory from sector 2 or 3 to sector 
                //      10 (a total of 8 sectors) which = 7 * 8 entries (lose 
                //      1 for file descriptor sector.
                //

                int nAllocationMap = 0x0000;

                switch (nSectorsPerCluster)
                {
                    case 1:
                        nAllocationMap = 0xFFE0; // 11 clusters = 11 sectors - 4 
                        nOS9DirSectors = 7;
                        break;
                    case 2:
                        nAllocationMap = 0xFF00; //  8 clusters = 16 sectors - 4
                        nOS9DirSectors = 12;
                        break;
                    case 4:
                        nAllocationMap = 0xF000; //  4 clusters = 16 sectors - 4
                        nOS9DirSectors = 12;
                        break;
                    case 8:
                        nAllocationMap = 0xC000; //  2 clusters = 16 sectors - 4
                        nOS9DirSectors = 12;
                        break;
                    case 16:
                        nAllocationMap = 0x8000; //  1 clusters = 16 sectors - 4
                        nOS9DirSectors = 12;
                        break;
                }

                ClearSectorBuffer();                                // memset(m_caSector, '\0', 256);     // clear the sector buffer

                m_caSector[0] = (byte)(nAllocationMap / 256);
                m_caSector[1] = (byte)(nAllocationMap % 256);

                // this only writes the first two bytes of the allocation bit map. 

                fp.Write(m_caSector, 0, 2);                       // write sector 1       (2)
                bytesWritten += 2;
            }
            catch (Exception e2)
            {
                MessageBox.Show("E2: " + e2.Message);
            }

            ClearSectorBuffer();                    //  memset(m_caSector, '\0', 256);     // clear the sector buffer

            //
            //  write additional blank allocation sectors as needed
            //

            //  We need to see how many more we need to write based on the number of bytes in the allocation bit map.

            int numberOfSectorsInImage = (int)(stIdentSector.cTOT[0] * 65536) + (int)(stIdentSector.cTOT[1] * 256) + (int)(stIdentSector.cTOT[2]);
            int numberOfBitsInAllocationBitMap = numberOfSectorsInImage / nSectorsPerCluster;

            // we have already written the first 2 bytes of the allocation bit map to the image and we do not want to write the last byte yet

            int remainingBytesToWrite = bytesInAllocationBitMap - 3;

            // this will fill out the remaing sectors in the ABM for available clusters up to but not including the last byte
            // because it may be only partially used (the first byte of m_caBuffer is already set to 0x00)

            while (remainingBytesToWrite > 0)
            {
                fp.Write(m_caSector, 0, 1);                       // write sector 1       (2)
                remainingBytesToWrite--;
                bytesWritten++;
            }

            // default to the clusters represented by the last byte are unavailable 

            byte[] lastByteInAllocationBitMap = new byte[1] { 0xFF };

            // see how many bits of the last byte we need to mark as available

            int totalNumberofBitsInLastByte = numberOfBitsInAllocationBitMap % 8;

            switch (totalNumberofBitsInLastByte)
            {
                case 0:
                    lastByteInAllocationBitMap[0] = 0x00;       // we are cool - full byte required write last byte as is
                    break;
                case 1:
                    lastByteInAllocationBitMap[0] = 0x7F;
                    break;
                case 2:
                    lastByteInAllocationBitMap[0] = 0x3F;
                    break;
                case 3:
                    lastByteInAllocationBitMap[0] = 0x1F;
                    break;
                case 4:
                    lastByteInAllocationBitMap[0] = 0x0F;
                    break;
                case 5:
                    lastByteInAllocationBitMap[0] = 0x07;
                    break;
                case 6:
                    lastByteInAllocationBitMap[0] = 0x03;
                    break;
                case 7:
                    lastByteInAllocationBitMap[0] = 0x01;
                    break;
            }

            fp.Write(lastByteInAllocationBitMap, 0, 1);
            bytesWritten++;

            // when done make sure the rest of the bits in the last sector are set to allocated.
            // now do the unavailable clusters to fill out the last sector (allocation bit map
            // comprises 2 sectors starting at LSN 1 (offset 0x000100 in the image)

            remainingBytesToWrite = 512 - bytesInAllocationBitMap;

            // this will fill out the remaing sectors in the ABM for available clusters up to but not including the last byte
            // because it may be only partially used

            while (remainingBytesToWrite > 0)
            {
                fp.Write(m_caSector, 0, 1);                       // write sector 1       (2)
                remainingBytesToWrite--;
                bytesWritten++;
            }

            return nOS9DirSectors;
        }

        private void CreateFloppy(string filename, BackgroundWorker worker, DoWorkEventArgs e)
        {
            try
            {
                using (FileStream fp = File.Open(filename, FileMode.CreateNew, FileAccess.Write, FileShare.None))  // fopen_s(&fp, (LPCTSTR)cDriveFileName, "wb");
                {
                    if (fp != null)
                    {
                        #region NEEDS WORK

                        alert.SetRange(0, nProgressSectors);                                            // ProgressDlg.SetRange(0, nProgressSectors);
                        alert.StepValue = 1;

                        DateTime ltime = DateTime.Now;                                                  // time(&lTime);
                                                                                                        // localtime_s(&today, &lTime);
                        RAW_SIR stSystemInformationRecord = new RAW_SIR();
                        OS9_ID_SECTOR stIdentSector = new OS9_ID_SECTOR();
                        int nOS9DirSectors = 0;
                        int nSectorsPerCluster = 1;

                        m_SectorsPerTrack  = Convert.ToInt32(txtEditSectors.Text);
                        m_SectorsPerTrack0 = Convert.ToInt32(txtEditSectors0.Text);

                        // place the volume name in the SIR

                        if (rdoRadioFlexFormat.Checked)
                        {
                            for (int i = 0; i < 11; i++)
                            {
                                if (i < m_volumeName.Length)
                                {
                                    string b = m_volumeName.Substring(i, 1);
                                    stSystemInformationRecord.caVolumeLabel[i] = (byte)b.ToCharArray(0, 1)[0];
                                }
                                else
                                    stSystemInformationRecord.caVolumeLabel[i] = (byte)0x00;
                            }

                            stSystemInformationRecord.cVolumeNumberHi = 0x00;
                            stSystemInformationRecord.cVolumeNumberLo = 0x00;
                            stSystemInformationRecord.cFirstUserTrack = 0x01;
                            stSystemInformationRecord.cFirstUserSector = 0x01;
                            stSystemInformationRecord.cLastUserTrack = (byte)(m_cCylindersPerDisk - 1);
                            stSystemInformationRecord.cLastUserSector = m_cSectorsPerCylinder;
                            stSystemInformationRecord.cTotalSectorsHi = (byte)(nTotalSectors / 256);    // this is the total number of sectors on cylinder 1 through number of cylinders
                            stSystemInformationRecord.cTotalSectorsLo = (byte)(nTotalSectors % 256);    // it does not include the sectors on cylinder 0.
                            stSystemInformationRecord.cMonth = (byte)(ltime.Month);
                            stSystemInformationRecord.cDay = (byte)(ltime.Day);
                            stSystemInformationRecord.cYear = (byte)(ltime.Year - 1900);
                            stSystemInformationRecord.cMaxTrack = (byte)(m_cCylindersPerDisk - 1);
                            stSystemInformationRecord.cMaxSector = m_cSectorsPerCylinder;
                        }
                        #region NOT_FLEX_FORMAT
                        else if (rdoRadioOs9Format.Checked)
                        {
                            nSectorsPerCluster = PrepareOS9SIRForCreate(ref stIdentSector, ltime);
                            if (nSectorsPerCluster > 16)
                            {
                                MessageBox.Show("Too many sectors in this format");
                                return;
                            }
                        }
                        else if (rdoRadioUniflexFormat.Checked)
                        {
                            MessageBox.Show("Not yet implemented");
                        }
                        else
                        {
                            MessageBox.Show("Unknown Format");
                        }
                        #endregion

                        ClearSectorBuffer();

                        // this just writes the boot sector

                        if (rdoRadioFlexFormat.Checked)
                        {
                            if (m_nIncludeBootSector)
                            {                                         // write boot sector    (0)
                                if (m_nProcessor == 6800)
                                    fp.Write(caBootSector6800, 0, 256);
                                else
                                {
                                    if (rdoRadioControllerFd2.Checked)
                                        fp.Write(caBootSector6809, 0, 256);
                                    else
                                        fp.Write(BootSector6809DMAF2, 0, 512);
                                }
                            }
                            else
                                fp.Write(m_caSector, 0, 256); // write empty boot sector   (0)
                        }
                        else if (rdoRadioOs9Format.Checked)
                        {
                            try
                            {
                                WriteOS9SIRToImage(fp, stIdentSector);
                            }
                            catch (Exception e1)
                            {
                                MessageBox.Show("E1: " + e1.Message);
                            }
                        }
                        else if (rdoRadioUniflexFormat.Checked)
                        {
                            MessageBox.Show("Not yet implemented");
                        }
                        else
                        {
                            MessageBox.Show("Unknown Format");
                        }

                        alert.StepIt();

                        // now write the next sector - we do this one separately for FLEX because the
                        // first sector after the boot is different for DMAF and non-DMAF controllers

                        if (rdoRadioFlexFormat.Checked)
                        {
                            // Only write the next sector if the format is FLEX and NOT DMAF

                            if (rdoRadioControllerFd2.Checked)
                            {
                                m_caSector[1] = (byte)3;         // link next sector to sector 3
                                fp.Write(m_caSector, 0, 256);    // write sector 1       (2)
                            }
                        }
                        else if (rdoRadioOs9Format.Checked)
                        {
                            nOS9DirSectors = WriteOS9AllocationBitMap(fp, stIdentSector, nSectorsPerCluster);
                        }
                        else if (rdoRadioUniflexFormat.Checked)
                        {
                            MessageBox.Show("Not yet implemented");
                        }
                        else
                        {
                            MessageBox.Show("Unknown Format");
                        }

                        alert.StepIt();

                        ClearSectorBuffer();

                        // now do the SIR

                        if (rdoRadioFlexFormat.Checked)
                        {
                            // memcpy(&m_caSector[16], &stSystemInformationRecord, 24);

                            for (int i = 0; i < 11; i++)
                                m_caSector[16 + i] = stSystemInformationRecord.caVolumeLabel[i];
                            m_caSector[27] = stSystemInformationRecord.cVolumeNumberHi;                    // $5B
                            m_caSector[28] = stSystemInformationRecord.cVolumeNumberLo;                    // $5C
                            m_caSector[29] = stSystemInformationRecord.cFirstUserTrack;                    // $5D
                            m_caSector[30] = stSystemInformationRecord.cFirstUserSector;                   // $5E
                            m_caSector[31] = stSystemInformationRecord.cLastUserTrack;                     // $5F
                            m_caSector[32] = stSystemInformationRecord.cLastUserSector;                    // $60
                            m_caSector[33] = stSystemInformationRecord.cTotalSectorsHi;                    // $61
                            m_caSector[34] = stSystemInformationRecord.cTotalSectorsLo;                    // $62
                            m_caSector[35] = stSystemInformationRecord.cMonth;                             // $63
                            m_caSector[36] = stSystemInformationRecord.cDay;                               // $64
                            m_caSector[37] = stSystemInformationRecord.cYear;                              // $65
                            m_caSector[38] = stSystemInformationRecord.cMaxTrack;                          // $66
                            m_caSector[39] = stSystemInformationRecord.cMaxSector;                         // $67

                            fp.Write(m_caSector, 0, 256);          // write SIR            (3)
                        }
                        else if (rdoRadioOs9Format.Checked)
                        {
                            ////
                            ////  write another allocation sector (blank)
                            ////

                            //ClearSectorBuffer();                    //  memset(m_caSector, '\0', 256);     // clear the sector buffer
                            //fp.Write(m_caSector, 0, 256);           //  write sector 2       (3)
                        }
                        else if (rdoRadioUniflexFormat.Checked)
                        {
                            MessageBox.Show("Not yet implemented");
                        }
                        else
                        {
                            MessageBox.Show("Unknown Format");
                        }

                        alert.StepIt();

                        // now do the directory sectors - starts at offset 0x400 into the image. This means that we
                        // already written 4 sectors to the diskette - the first sector of the directory will be
                        // written to sector 5.

                        if (rdoRadioFlexFormat.Checked)
                        {
                            //Now we can write the directory sectors and link them

                            ClearSectorBuffer();

                            int remainingSectors = (int)m_nSectorsPerCylinder;

                            if (checkBoxGoTekCompatible.Checked)
                            {
                                if (chkCheckDoubleSided.Checked)
                                    remainingSectors = 20;
                                else
                                    remainingSectors = 10;
                            }

                            for (int i = 4; i < remainingSectors; i++)
                            {
                                m_caSector[1] = (byte)(i + 1);
                                fp.Write(m_caSector, 0, 256);  // write a directory sector
                                alert.StepIt();
                            }

                            ClearSectorBuffer();
                            
                            fp.Write(m_caSector, 0, 256);      // write last unlinked directory sector
                        }
                        else if (rdoRadioOs9Format.Checked)
                        {
                            try
                            {
                                // If OS9, write the rest of track 0 side 0 starting with sector 3

                                ClearSectorBuffer();                //  memset(m_caSector, '\0', 256); // clear the sector buffer again

                                // set up file descriptor for root directory

                                m_caSector[0] = 0xBF;                      // File Attributes
                                m_caSector[1] = 0x00;                      // Owners User ID Hi byte
                                m_caSector[2] = 0x00;                      // Owners User ID Lo Byte
                                m_caSector[3] = (byte)(ltime.Year - 1900); // date modified Y M D H M            
                                m_caSector[4] = (byte)(ltime.Month);
                                m_caSector[5] = (byte)(ltime.Day);         // today.tm_mday;
                                m_caSector[6] = (byte)(ltime.Hour);        // today.tm_hour;
                                m_caSector[7] = (byte)(ltime.Minute);      // today.tm_min;
                                m_caSector[8] = 0x02;                      // link count
                                m_caSector[9] = 0x00;                      // first  byte of file size
                                m_caSector[10] = 0x00;                      // second byte of file size
                                m_caSector[11] = 0x00;                      // third  byte of file size
                                m_caSector[12] = 0x40;                      // last   byte of file size

                                m_caSector[13] = (byte)(ltime.Year - 1900);  // date modified Y M D H M  
                                m_caSector[14] = (byte)(ltime.Month);
                                m_caSector[15] = (byte)(ltime.Day);          // today.tm_mday;

                                // first entry in segment list

                                m_caSector[16] = 0x00;                      // first  byte of logical sector
                                m_caSector[17] = 0x00;                      // second byte of logical sector
                                m_caSector[18] = 0x04;                      // third  byte of logical sector
                                m_caSector[19] = 0x00;                      // first  byte of segment size
                                m_caSector[20] = (byte)nOS9DirSectors;      // second byte of segment size

                                fp.Write(m_caSector, 0, 256);               // write OS9 sector 3

                                alert.StepIt();

                                ClearSectorBuffer();                //  memset(m_caSector, '\0', 256); // clear the sector buffer again

                                // set up initial root directory

                                m_caSector[0] = 0x2E;
                                m_caSector[1] = 0xAE;
                                m_caSector[31] = 0x03;              // root directory file descriptor
                                m_caSector[32] = 0xAE;
                                m_caSector[63] = 0x03;              // root directory file descriptor

                                fp.Write(m_caSector, 0, 256);       // write OS9 sector 4
                                alert.StepIt();

                                // write the rest of the sectors ( 6 - atoi (sectorsPerTrack)) to finish out track 0 side 0 and side 1
                                //
                                //      note sector numbers are zero based - so sector 4 is the 5th sector - that is why we are subtracting 5 from
                                //      sectors per track to calculate remaining sectors to write for track 0

                                ClearSectorBuffer();                // clear the sector buffer again

                                int remainingSectorsCylinderZero = m_SectorsPerTrack0 - 5;          // do the whole remaining sylinder here.
                                if (chkCheckDoubleSided.Checked)
                                    remainingSectorsCylinderZero += m_SectorsPerTrack;

                                for (int i = 0; i < remainingSectorsCylinderZero; i++)
                                {
                                    fp.Write(m_caSector, 0, 256);
                                    alert.StepIt();
                                }

                                //// now write track 0 side 1

                                //for (int i = 0; i < m_SectorsPerTrack; i++)
                                //{
                                //    fp.Write(m_caSector, 0, 256);      // write a director sector
                                //    alert.StepIt();
                                //}
                            }
                            catch (Exception e3)
                            {
                                MessageBox.Show("E3: " + e3.Message);
                            }
                        }
                        else if (rdoRadioUniflexFormat.Checked)
                        {
                            MessageBox.Show("Not yet implemented");
                        }
                        else
                        {
                            MessageBox.Show("Unknown Format");
                        }

                        //Now we can write the user sectors and link them
                        //
                        //  we have already written track 0 - so start with 1 instead of zero
                        //
                        //      

                        for (int j = 1; j < m_nCylindersPerDisk; j++)
                        {
                            //if (!pProgressDlg.CheckCancelButton())
                            {
                                for (int i = 1; i < (int)m_nSectorsPerCylinder; i++)
                                {
                                    if (rdoRadioFlexFormat.Checked)
                                    {
                                        m_caSector[0] = (byte)j;            // set track  link to next sector
                                        m_caSector[1] = (byte)(i + 1);      // set sector link to next sector
                                    }
                                    fp.Write(m_caSector, 0, 256);  // write a director sector
                                    alert.StepIt();
                                }

                                // Do last sector of track - this is for FLEX only to terminate the free chain

                                if (j == (m_nCylindersPerDisk - 1))     // handle last sector on disk
                                {
                                    if (rdoRadioFlexFormat.Checked)
                                    {
                                        ClearSectorBuffer();            // clear the sector buffer again
                                        fp.Write(m_caSector, 0, 256);   // write a directory sector
                                        alert.StepIt();
                                    }
                                    else
                                    {
                                        // behave normally if not FLEX

                                        fp.Write(m_caSector, 0, 256);   // write a directory sector
                                        alert.StepIt();
                                    }
                                }
                                else                                  // all others
                                {
                                    if (rdoRadioFlexFormat.Checked)
                                    {
                                        m_caSector[0] = (byte)(j + 1);        // set track  link to next sector
                                        m_caSector[1] = (byte)1;            // set sector link to next sector
                                    }
                                    fp.Write(m_caSector, 0, 256);  // write a director sector
                                    alert.StepIt();
                                }
                            }
                            // else    // Cancel from ProgressDialog Received
                            //{
                            //    nProgressCanceled = TRUE;
                            //    break;
                            //}
                        }
                        #endregion

                        for (int i = 1; i <= 10; i++)
                        {
                            if (worker.CancellationPending == true)
                            {
                                e.Cancel = true;
                                break;
                            }
                            else
                            {
                                // Perform a time consuming operation and report progress.
                                worker.ReportProgress(i * 10);
                                System.Threading.Thread.Sleep(500);
                            }
                        }

                        //fp.Close();

                        //if (nProgressCanceled)
                        //{
                        //    unlink((LPCTSTR)cDriveFileName);
                        //}
                    }
                }
            }
            catch (Exception e4)
            {
                MessageBox.Show("E4: " + e4.Message);
            }
        }

        private string GetFileNameToCreate()
        {
            string strDefaultDir = Program.GetConfigurationAttribute("Directories", "DefaultFormatDir", "");

            SaveFileDialog pDlg = new SaveFileDialog();

            pDlg.DefaultExt = ".DSK";
            pDlg.InitialDirectory = strDefaultDir;
            pDlg.FileName = m_volumeName + ".DSK";

            if (checkBoxGoTekCompatible.Checked)
            {
                pDlg.DefaultExt = ".GTI";
                pDlg.FileName = m_volumeName + ".GTI";
            }
            DialogResult dr = pDlg.ShowDialog();

            if (dr == DialogResult.OK)
            {
                if (File.Exists(pDlg.FileName))
                    File.Delete(pDlg.FileName);

                return pDlg.FileName;
            }
            return null;
        }

        private void btnStart_Click(object sender, EventArgs e)
        {
            createdDisk = true;

            m_nProcessor                    = 6809;
            m_nIncludeBootSector            = chkCheckIncludeBootSector.Checked;
            
            m_35Track                       = rdoRadio35Track.Checked;
            m_40Track                       = rdoRadio40Track.Checked;
            m_80Track                       = rdoRadio80Track.Checked;
            m_UserDefined                   = rdoRadioUserDefined.Checked;
            
            m_DoubleDensity                 = rdoRadioDoubleDensity.Checked;
            m_SingleDensity                 = rdoRadioSingleDensity.Checked;
            m_QuadDensity                   = rdoRadioQuadDensity.Checked;
            m_DoubleSided                   = chkCheckDoubleSided.Checked;

            Int32.TryParse(txtEditTracks.Text  , out m_UserDefinedCylindersPerDisk);
            Int32.TryParse(txtEditSectors.Text , out m_UserDefinedSectorsPerTrack );
            Int32.TryParse(txtEditSectors0.Text, out m_SectorsPerTrack0);

            if (rdoRadio35Track.Checked)
                m_nCylindersPerDisk = 35;
            else if (rdoRadio40Track.Checked)
                m_nCylindersPerDisk = 40;
            else if (rdoRadio80Track.Checked)
                m_nCylindersPerDisk = 80;
            else if (rdoRadioUserDefined.Checked)
                m_nCylindersPerDisk = m_UserDefinedCylindersPerDisk;

            if (rdoRadioFlexFormat.Checked)
                m_fileFormat = "FLEX";
            else if (rdoRadioOs9Format.Checked)
                m_fileFormat = "OS9";
            else if (rdoRadioUniflexFormat.Checked)
                m_fileFormat = "UNIFLEX";
            else
            {
                MessageBox.Show("No format specified");
                return;
            }

            if (!rdoRadioUniflexFormat.Checked)
            {

                // Save to Config File

                FileStream fileStream = File.OpenRead(Program.configFileName);
                XmlReader reader = XmlReader.Create(fileStream);
                XmlDocument newDoc = null;

                if (reader != null)
                {
                    XmlDocument doc = new XmlDocument();
                    if (doc != null)
                    {
                        doc.Load(reader);

                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "Format", m_fileFormat);

                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "Processor", m_nProcessor.ToString());
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "IncludeBootSector", m_nIncludeBootSector ? "1" : "0");

                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "Tracks35", m_35Track ? "1" : "0");
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "Tracks40", m_40Track ? "1" : "0");
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "Tracks80", m_80Track ? "1" : "0");
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "UserDefined", m_UserDefined ? "1" : "0");

                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "DoubleDensity", m_DoubleDensity ? "1" : "0");
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "SingleDensity", m_SingleDensity ? "1" : "0");
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "QuadDensity", m_QuadDensity ? "1" : "0");
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "DoubleSided", m_DoubleSided ? "1" : "0");

                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "UserDefinedCylinders", m_UserDefinedCylindersPerDisk.ToString());
                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "UserDefinedSectors", m_UserDefinedSectorsPerTrack.ToString());

                        if (rdoRadioControllerFd2.Checked)
                            m_nControllerType = (int)ControllerTypes.CONTROLLER_TYPE_FD2;
                        else if (rdoRadioControllerDmaf2.Checked)
                            m_nControllerType = (int)ControllerTypes.CONTROLLER_TYPE_DMAF2;

                        Program.SaveConfigurationAttribute(doc, "Global/FileMaintenance/FloppyCreate", "ControllerType", m_nControllerType.ToString());

                        newDoc = (XmlDocument)doc.Clone();
                    }
                    reader.Close();
                    reader.Dispose();

                    fileStream.Close();

                    newDoc.Save(Program.configFileName);

                    // ----------------------------------------------------------
                    int nTooManySectors;

                    m_cCylindersPerDisk = (byte)m_nCylindersPerDisk;

                    // Get the number of sectors per TRACK to calculate the number of sectors per Cylinder

                    string sectorsPerTrack  = m_UserDefinedSectorsPerTrack.ToString();                     // m_EditSectorsPerTrack.GetWindowText(sectorsPerTrack);
                    int m_nSectorsPerTrack = Int32.Parse(sectorsPerTrack);

                    m_nSectorsPerCylinder = m_nSectorsPerTrack * (m_DoubleSided ? 2 : 1);     // m_nSectorsPerCylinder = atoi (sectorsPerTrack) * (pApp->m_DoubleSided ? 2 : 1);

                    if (rdoRadioFlexFormat.Checked)
                        nTooManySectors = 256;
                    else
                        nTooManySectors = 257;

                    if (m_nSectorsPerCylinder < nTooManySectors)
                    {
                        if (m_UserDefined)
                        {
                            m_UserDefinedCylindersPerDisk = m_CylindersPerDisk;
                            m_UserDefinedSectorsPerTrack = m_SectorsPerTrack;
                        }

                        m_cSectorsPerCylinder = (byte)m_nSectorsPerCylinder;

                        if (rdoRadioFlexFormat.Checked)
                        {
                            // get the number of sectors that will be on sylinder 1 through number of cylinders

                            nTotalSectors = m_cSectorsPerCylinder * (m_nCylindersPerDisk - 1);
                            nProgressSectors = m_cSectorsPerCylinder * (m_nCylindersPerDisk);
                        }
                        else if (rdoRadioOs9Format.Checked)
                        {
                            nTotalSectors = m_nSectorsPerCylinder * (m_nCylindersPerDisk);
                            nProgressSectors = m_nSectorsPerCylinder * (m_nCylindersPerDisk);

                            m_nIncludeBootSector = false;

                            if (m_nSectorsPerTrack > m_SectorsPerTrack0)
                            {
                                nTotalSectors    -= (m_nSectorsPerTrack - m_SectorsPerTrack0);
                                nProgressSectors -= (m_nSectorsPerTrack - m_SectorsPerTrack0);
                            }
                        }
                        else if (rdoRadioUniflexFormat.Checked)
                        {
                            nTotalSectors = m_cSectorsPerCylinder * (m_nCylindersPerDisk - 1);
                            nProgressSectors = m_cSectorsPerCylinder * (m_nCylindersPerDisk);

                            m_nIncludeBootSector = chkCheckIncludeBootSector.Checked;
                        }
                    }

                    // ----------------------------------------------------------

                    m_volumeName = txtEditVolumeName.Text;

                    filename = GetFileNameToCreate();
                    if (filename != null)
                    {
                        if (backgroundWorker1.IsBusy != true)
                        {
                            // create a new instance of the alert form

                            alert = new frmProgress();

                            // event handler for the Cancel button in AlertForm

                            alert.Canceled += new EventHandler<EventArgs>(cancelAsyncButton_Click);
                            alert.Text = "Creating Floppy Image file: " + Path.GetFileName(filename);
                            alert.Show();
                            alert.TopMost = true;

                            // Start the asynchronous operation.

                            backgroundWorker1.RunWorkerAsync();
                        }
                    }
                }
            }
            else
            {
                MessageBox.Show("Not yet implemented");
            }
        }

        // This event handler cancels the backgroundworker, fired from Cancel button in AlertForm.

        private void cancelAsyncButton_Click(object sender, EventArgs e)
        {
            if (backgroundWorker1.WorkerSupportsCancellation == true)
            {
                // Cancel the asynchronous operation.
                backgroundWorker1.CancelAsync();
                // Close the AlertForm
                alert.Close();
            }
        }

        private void frmDialogDiskParameters_Load(object sender, EventArgs e)
        {
            chkCheckIncludeBootSector.Checked   = m_nIncludeBootSector         ;

            rdoRadio35Track.Checked             = m_35Track                    ;
            rdoRadio40Track.Checked             = m_40Track                    ;
            rdoRadio80Track.Checked             = m_80Track                    ;
            rdoRadioUserDefined.Checked         = m_UserDefined                ;
 
            rdoRadioDoubleDensity.Checked       = m_DoubleDensity              ;
            rdoRadioSingleDensity.Checked       = m_SingleDensity              ;
            rdoRadioQuadDensity.Checked         = m_QuadDensity                ;
            chkCheckDoubleSided.Checked         = m_DoubleSided                ;

            txtEditTracks.Text                  = m_UserDefinedCylindersPerDisk.ToString();
            txtEditSectors.Text                 = m_UserDefinedSectorsPerTrack .ToString();
            txtEditSectors0.Text                = m_SectorsPerTrack0.ToString();

            if (m_nControllerType == (int)ControllerTypes.CONTROLLER_TYPE_FD2)
                rdoRadioControllerFd2.Checked = true;
            else
                rdoRadioControllerDmaf2.Checked = true;

            switch (m_fileFormat.ToUpper())
            {
                case "FLEX":
                    rdoRadioFlexFormat.Checked = true;
                    break;
                case "UNIFLEX":
                    rdoRadioUniflexFormat.Checked = true;
                    break;
                case "OS9":
                    rdoRadioOs9Format.Checked = true;
                    break;

                default:
                    rdoRadioFlexFormat.Checked = true;
                    break;
            }
        }

        private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e)
        {
            BackgroundWorker worker = sender as BackgroundWorker;
            CreateFloppy(filename, worker, e);
        }

        private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            // Show the progress in main form (GUI)

            //labelResult.Text = (e.ProgressPercentage.ToString() + "%");

            // Pass the progress to AlertForm label and progressbar

            alert.Message = "In progress, please wait... " + e.ProgressPercentage.ToString() + "%";
            alert.ProgressValue = e.ProgressPercentage;
        }

        private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            //if (e.Cancelled == true)
            //{
            //    labelResult.Text = "Canceled!";
            //}
            //else if (e.Error != null)
            //{
            //    labelResult.Text = "Error: " + e.Error.Message;
            //}
            //else
            //{
            //    labelResult.Text = "Done!";
            //}

            // Close the AlertForm

            alert.Close();
        }

        private void btnClose_Click(object sender, EventArgs e)
        {

        }

        void SetSectorsPerTrack ()
        {
            if (rdoRadioSingleDensity.Checked)
                txtEditSectors.Text = "10";
            else if (rdoRadioDoubleDensity.Checked)
                txtEditSectors.Text = "18";
            else if (rdoRadioQuadDensity.Checked)
                txtEditSectors.Text = "36";

            if (rdoRadioOs9Format.Checked)
            {
                // default to 10 sectors on track 0 if OS9 format

                txtEditSectors0.Text = "10";
            }
        }
        private void rdoRadio35Track_CheckedChanged(object sender, EventArgs e)
        {
            txtEditSectors.Enabled = false;
            txtEditTracks.Enabled = false;
            txtEditTracks.Text = "35";

            SetSectorsPerTrack();
        }

        private void rdoRadio40Track_CheckedChanged(object sender, EventArgs e)
        {
            txtEditSectors.Enabled = false;
            txtEditTracks.Enabled = false;
            txtEditTracks.Text = "40";

            SetSectorsPerTrack();
        }

        private void rdoRadio80Track_CheckedChanged(object sender, EventArgs e)
        {
            txtEditSectors.Enabled = false;
            txtEditTracks.Enabled = false;
            txtEditTracks.Text = "80";

            SetSectorsPerTrack();
        }

        private void rdoRadioUserDefined_CheckedChanged(object sender, EventArgs e)
        {
            txtEditSectors.Enabled = true;
            txtEditTracks.Enabled = true;
        }

        private void rdoRadioSingleDensity_CheckedChanged(object sender, EventArgs e)
        {
            if (!rdoRadioUserDefined.Checked)
                txtEditSectors.Text = "10";
        }

        private void rdoRadioDoubleDensity_CheckedChanged(object sender, EventArgs e)
        {
            if (!rdoRadioUserDefined.Checked)
                txtEditSectors.Text = "18";
        }

        private void rdoRadioQuadDensity_CheckedChanged(object sender, EventArgs e)
        {
            if (!rdoRadioUserDefined.Checked)
                txtEditSectors.Text = "36";
        }

        private void chkCheckDoubleSided_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void labelSectorsTrackZero_MouseHover(object sender, EventArgs e)
        {
            ToolTip toolTip = new System.Windows.Forms.ToolTip();
            toolTip.ShowAlways = true;
            toolTip.SetToolTip(labelSectorsTrackZero, "The number of sectors on track 0 side 0");
        }

        private void chkCheckDoubleSided_MouseHover(object sender, EventArgs e)
        {
            ToolTip toolTip = new System.Windows.Forms.ToolTip();
            toolTip.ShowAlways = true;
            toolTip.SetToolTip(chkCheckDoubleSided, "This will multiply the number of sectors by 2");
        }

        private void rdoRadioUserDefined_MouseHover(object sender, EventArgs e)
        {
            ToolTip toolTip = new System.Windows.Forms.ToolTip();
            toolTip.ShowAlways = true;
            toolTip.SetToolTip(rdoRadioUserDefined, "Track and Sector will be ignored");
        }

        private void rdoRadioFlexFormat_CheckedChanged(object sender, EventArgs e)
        {
            if (rdoRadioFlexFormat.Checked)
            {
                labelSectorsTrackZero.Visible = false;
                txtEditSectors0.Visible = false;

                checkBoxGoTekCompatible.Top = labelSectorsTrackZero.Top;
                checkBoxGoTekCompatible.Left = labelSectorsTrackZero.Left + 40;

                checkBoxGoTekCompatible.Visible = true;
            }
        }

        private void rdoRadioOs9Format_CheckedChanged(object sender, EventArgs e)
        {
            if (rdoRadioOs9Format.Checked)
            {
                labelSectorsTrackZero.Visible = true;
                txtEditSectors0.Visible = true;

                checkBoxGoTekCompatible.Visible = false;
            }
        }

        private void rdoRadioUniflexFormat_CheckedChanged(object sender, EventArgs e)
        {
            if (rdoRadioUniflexFormat.Checked)
            {
                labelSectorsTrackZero.Visible = false;
                txtEditSectors0.Visible = false;

                checkBoxGoTekCompatible.Visible = false;
            }
        }
    }
}
